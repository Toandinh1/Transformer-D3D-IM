import numpy as np
import tensorflow as tf
from scipy.special import binom
import torch
import torch.nn as nn

M = 4
N = 4
K = 2

SNRdB = 10
SNRdB_2 = 20

training_epochs = 1001
l_rate = 0.001
l_rate_1 = 0.0002
total_batch = 20
batch_size = 1000

n_input = 3*N
n_input_1 = 3*N*2
n_hidden_1 = 256
n_hidden_2 = 768
n_hidden_3 = n_hidden_1 + n_hidden_2
n_hidden_4 = 256
bps = int(np.log2(M))
p1 = int(np.log2(binom(N,K)))
p2 = K*bps
p3 = (N-K)*bps
q = p1+p2+p3
Q = 2**q
n_output = q

display_step = 5
SNR = 10**(SNRdB/10)
sigma = np.sqrt(1/SNR)

bits = np.random.binomial(n=1,p=0.5,size=(q,))
a = 1/np.sqrt(2)
if M == 2:
    modA_2 = np.array(([1,1,1],[-1,-1,1]),dtype=float)
    modB_2 = np.array(([1,-1,-1],[-1,1,-1]),dtype=float)
    BER_ML_Detector = np.array([0.062,0.0095,0.0011,0.00012,0.000012,0.0000012,0])
if M == 4:
    modA_2 = np.array(([1,1,1],[-1,-1,1],[1, -1, -1],[-1, 1, -1]),dtype=float)
    modB_2 = np.array(([1,-1,-1],[-1,1,-1],[1, 1, -1],[-1, -1, -1]),dtype=float)
    BER_ML_Detector = np.array([0.21,0.072,0.0134,0.00165,0.00015,0.000009,0])

idx = np.array([[0,1],[2,3],[0,2],[1,3]])

def ThreeD_DM_OFDM(bits,SNRdB):
    bit_id = bits[0:p1:1]
    id_de = bit_id.dot(2**np.arange(bit_id.size)[::-1])
    bit_sy = bits[p1:p1+p2:1]
    bit_sy_si = bits[p1+p2:q:1]
    bit_K = bit_sy.reshape(-1,bps)
    bit_K_si = bit_sy_si.reshape(-1,bps)
    sy_de = np.zeros((K),dtype=int)
    sy_de_si = np.zeros((N-K),dtype=int)
    sym = np.zeros((K,3),dtype=float)
    sym_si = np.zeros((K,3),dtype=float)
    for i in range(K):
        bit_sy_i = bit_K[i,:]
        bit_sy_i_si = bit_K_si[i,:]
        sy_de[i] = bit_sy_i.dot(2**np.arange(bit_sy_i.size)[::-1])
        sy_de_si[i] = bit_sy_i_si.dot(2**np.arange(bit_sy_i_si.size)[::-1])
        sym[i] = modA_2[sy_de[i]]
        sym_si[i] = modB_2[(sy_de_si[i])]
    tx_sym = np.zeros((N,3),dtype=float)
    tx_sym[idx[id_de,:]] = sym
    tx_sym[~idx[id_de,:]] = sym_si
    
    SNR = 10**(SNRdB/10)
    sigma = np.sqrt(1/SNR)
    eps = 0.0
    
    noise = np.sqrt(1/2)*(np.random.randn(*tx_sym.shape)+1j*np.random.randn(*tx_sym.shape))
    h = np.sqrt((1-eps)/2)*(np.random.randn(*tx_sym.shape)+1j*np.random.randn(*tx_sym.shape))
    #h = 1*np.sqrt(SNR);
    e = np.sqrt(eps/2)*(np.random.randn(*tx_sym.shape)+1j*np.random.randn(*tx_sym.shape))
    h1 = h + e
    
    y = np.sqrt(SNR)*h1*tx_sym+noise
    
    y_bar = y/h
    y_con = np.concatenate((np.real(y),np.imag(y)))
    y_m = np.absolute(y)
    Y1 = y_m.reshape([n_input,])
    Y2 = y_con.reshape([n_input_1,])
    
    return Y1,Y2

def ThreeD_DM_OFDM_test(bits,SNRdB):
    bit_id = bits[0:p1:1]
    id_de = bit_id.dot(2**np.arange(bit_id.size)[::-1])
    
    bit_sy = bits[p1:p1+p2:1]
    bit_sy_si = bits[p1+p2:q:1]
    bit_K = bit_sy.reshape(-1,bps)
    bit_K_si = bit_sy_si.reshape(-1,bps)
    
    sy_de = np.zeros((K),dtype=int)
    sy_de_si = np.zeros((N-K),dtype=int)
    sym = np.zeros((K,3),dtype=float)
    sym_si = np.zeros((K,3),dtype=float)
    for i in range(K):
        bit_sy_i = bit_K[i,:]
        bit_sy_i_si = bit_K_si[i,:]
        sy_de[i] = bit_sy_i.dot(2**np.arange(bit_sy_i.size)[::-1])
        sy_de_si[i] = bit_sy_i_si.dot(2**np.arange(bit_sy_i_si.size)[::-1])
        sym[i] = modA_2[sy_de[i]]
        sym_si[i] = modB_2[(sy_de_si[i])]
        
    tx_sym = np.zeros((N,3),dtype=float)
    tx_sym[idx[id_de,:]] = sym
    tx_sym[~idx[id_de,:]] = sym_si
    
    SNR = 10**(SNRdB/10)
    sigma = np.sqrt(1/SNR)
    eps = 0.0
    
    noise = np.sqrt(1/2)*(np.random.randn(*tx_sym.shape)+1j*np.random.randn(*tx_sym.shape))
    h = np.sqrt((1-eps)/2)*(np.random.randn(*tx_sym.shape)+1j*np.random.randn(*tx_sym.shape))
    #h=1*np.sqrt(SNR);
    e = np.sqrt(eps/2)*(np.random.randn(*tx_sym.shape)+1j*np.random.randn(*tx_sym.shape))
    h1 = h + e
    
    y = np.sqrt(SNR)*h1*tx_sym+noise
    
    y_bar = y/h
    y_con = np.concatenate((np.real(y_bar),np.imag(y_bar)))
    y_m = np.absolute(y)
    Y1 = y_m.reshape([n_input,])
    Y2 = y_con.reshape([n_input_1,])
    
    return Y1,Y2

X = tf.placeholder("float",[None, n_input])
X_1 = tf.placeholder("float",[None, n_input_1])
Y = tf.placeholder("float",[None, n_output])
initializer = tf.contrib.layers.xavier_initializer()

def encoder(x,x_1):
    weights = {
        'encoder_h1': tf.Variable(initializer([n_input, n_hidden_1])),
        'encoder_h2': tf.Variable(initializer([n_input_1, n_hidden_2])),
        'encoder_h3': tf.Variable(initializer([n_hidden_3, n_hidden_4])),
        'encoder_h4': tf.Variable(initializer([n_hidden_4, n_output])),
    }
    
    biases = {
        'encoder_b1': tf.Variable(initializer([n_hidden_1])),
        'encoder_b2': tf.Variable(initializer([n_hidden_2])),
        'encoder_b3': tf.Variable(initializer([n_hidden_4])),
        'encoder_b4': tf.Variable(initializer([n_output])),
    }
    layer_1_a = tf.nn.tanh(tf.add(tf.matmul(x, weights['encoder_h1']), biases['encoder_b1']))
    layer_1_b = tf.nn.tanh(tf.add(tf.matmul(x_1, weights['encoder_h2']), biases['encoder_b2']))
    layer_1 = tf.concat([layer_1_a,layer_1_b],axis=1)
    layer_2 = tf.nn.tanh(tf.add(tf.matmul(layer_1, weights['encoder_h3']), biases['encoder_b3']))
    layer_3 = tf.nn.sigmoid(tf.add(tf.matmul(layer_2, weights['encoder_h4']), biases['encoder_b4']))

    return layer_3

y_pred = encoder(X,X_1)
y_true = Y

cost = tf.reduce_mean(tf.pow(y_true - y_pred,2))
learning_rate = tf.placeholder(tf.float32,shape=[])
optimizer = tf.train.AdamOptimizer(learning_rate).minimize(cost)
init = tf.global_variables_initializer()

def frange(x,y,jump):
    while x < y:
        yield x
        x +=jump

#Training and testing phases

with tf.Session() as sess:
    #Training
    sess.run(init)
    input_samples_SNR_1 = []
    input_samples_1_SNR_1 = []
    input_labels_SNR_1 = []
    for index_k in range(0, 1e+7):
        bits = np.random.binomial(n=1,p=0.5,size=(q,))
        signal_output,signal_output_1 = ThreeD_DM_OFDM(bits,SNRdB)
        input_labels_SNR_1.append(bits)
        input_samples_SNR_1.append(signal_output)
        input_samples_1_SNR_1.append(signal_output_1)
                
    data_SNR_1 = np.asarray(input_samples_SNR_1)
    data_1_SNR_1 = np.asarray(input_samples_1_SNR_1)
    label_SNR_1 = np.asarray(input_labels_SNR_1)

    input_samples_SNR_2 = []
    input_samples_1_SNR_2 = []
    input_labels_SNR_2 = []
    for index_k in range(0, 1e+7):
        bits = np.random.binomial(n=1,p=0.5,size=(q,))
        signal_output,signal_output_1 = ThreeD_DM_OFDM(bits,SNRdB_2)
        input_labels_SNR_2.append(bits)
        input_samples_SNR_2.append(signal_output)
        input_samples_1_SNR_2.append(signal_output_1)
                
    data_SNR_2 = np.asarray(input_samples_SNR_1)
    data_1_SNR_2 = np.asarray(input_samples_1_SNR_1)
    label_SNR_2 = np.asarray(input_labels_SNR_1)
    for epoch in range(training_epochs):
        avg_cost = 0
        for index_m in range(total_batch):
            input_samples = []
            input_samples_1 = []
            input_labels = []
            for index_k in range(0, batch_size):
                bits = np.random.binomial(n=1,p=0.5,size=(q,))
                signal_output,signal_output_1 = ThreeD_DM_OFDM(bits,SNRdB)
                input_labels.append(bits)
                input_samples.append(signal_output)
                input_samples_1.append(signal_output_1)
                
            batch_x = np.asarray(input_samples)
            batch_x_1 = np.asarray(input_samples_1)
            batch_y = np.asarray(input_labels)
            _,cs = sess.run([optimizer,cost], feed_dict={X:batch_x,
                                                         X_1: batch_x_1,
                                                        Y:batch_y,
                                                        learning_rate:l_rate})
            avg_cost += cs / total_batch
        if epoch % display_step == 0:
            print("Epoch:",'%04d' % (epoch+1), "cost=", \
               "{:.9f}".format(avg_cost))
            
    #Testing
    EbNodB_range = list(frange(0,35,5))
    ber = [None]*len(EbNodB_range)
    for n in range(0,len(EbNodB_range)):
        input_samples_test = []
        input_samples_test_1 = []
        input_labels_test = []
        test_number = 100000
        if n>10:
            test_number = 1000000
        for i in range(0, test_number):
            bits = np.random.binomial(n=1, p=0.5, size=(q, )) 
            signal_output,signal_output_1 = ThreeD_DM_OFDM_test(bits, EbNodB_range[n])
            input_labels_test.append(bits)
            input_samples_test_1.append(signal_output_1)
            input_samples_test.append(signal_output)
            
        batch_x = np.asarray(input_samples_test)
        batch_x_1 = np.asarray(input_samples_test_1)
        batch_y = np.asarray(input_labels_test)
        
        mean_error = tf.reduce_mean(abs(y_pred - batch_y)) # mean_error.eval({X:batch_x}),
        mean_error_rate = 1-tf.reduce_mean(tf.reduce_mean(tf.to_float(tf.equal(tf.sign(y_pred-0.5), tf.cast(tf.sign(batch_y-0.5),tf.float32))),1))
        ber[n]  = mean_error_rate.eval({X:batch_x,X_1:batch_x_1}) # eval
        print("SNR=", EbNodB_range[n], "BER:", ber[n])
    import matplotlib.pyplot as plt
    print("SNR_Gap=",-np.log10(ber-BER_ML_Detector))
    plt.plot(EbNodB_range, ber, 'bo-',label='DL 3M OFDM IM detection Y-Shape')
    plt.plot(EbNodB_range,BER_ML_Detector,'ro-',label='DM-3D-OFDM-ML')
    #plt.plot(list(EbNodB_range), ber_theory, 'ro-',label='BPSK BER')
    plt.yscale('log')
    plt.xlabel('SNR Range')
    plt.ylabel('BER')
    plt.grid()
    plt.legend(loc='upper right',ncol = 1)
    #plt.savefig('DL_Detection_IM_BER_matplotlib')
    plt.show()
